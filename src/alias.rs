/*! Dealing with the aliases file

This module is separated in two parts: the reading and writing functions.
Reading functions use the `ra` module (read-aliases)
and writing ones use `wa` (write-aliases)
*/
prelude!();
use crate::file;
use crate::config::FullConfig;
use std::io::{self, BufReader, BufRead, BufWriter, Write};
use std::{fs, path::PathBuf, fs::File};

/// String before the JSON list of old aliases
const JSON_PREFIX :&str = "# Generated from: ";
/// Error message when the home directory could not be found
const NOHOME_FMSG :&str = "Failed to find aliases file because the home directory could not be determined";

/// Module for `read_aliases`
pub mod ra {
	prelude!();
	use std::{result, io, path::PathBuf};
	use super::NOHOME_FMSG;
	
	#[derive(ThisError, Debug)]
	pub enum Error {
		#[error("{}", NOHOME_FMSG)]
		FindFileF,
		#[error("Aliases file {0:?} doesn't exist")]
		NoFileF(PathBuf), // We don't keep the io::Error bc it is unhelpful
		#[error("Failed to read from aliases file {0:?}")]
		ReadFileF(PathBuf, #[source] io::Error), // Remember to mention if the file exists
		#[error("\"Generated from\" line not found in aliases file {0:?}")]
		NoJsonLine(PathBuf),
		#[error("Failed to parse the list of old aliases as JSON in {0:?}")]
		FromJsonF(PathBuf, #[source] serde_json::Error),
	}

	/// Constructor for Io errors that checks if the file exists or not
	#[allow(non_snake_case)] // Because we pretend it's a error category
	pub fn IoF(p :PathBuf, e :io::Error) -> Error {
		use io::ErrorKind::*;
		match e.kind() {
			NotFound => Error::NoFileF(p),
			_ => Error::ReadFileF(p, e)
		}
	}

	pub type Result<T> = result::Result<T, self::Error>;
}

/// Find the line containing the old aliases JSON
fn find_prefix_line(buf :BufReader<File>, path :PathBuf) -> ra::Result<(String, PathBuf)> {
	use ra::Error::*;
	let mut line :Option<String> = None;
	
	// Find it
	for l in buf.lines() {
		let s = terror! { l => |e| ReadFileF(path, e) };
		if s.starts_with(JSON_PREFIX) {
			line = Some(s);
			break;
		}
	}
	let line = terror! { line => |_| NoJsonLine(path) };
	
	Ok((line, path))
}

/// Returns the list of old aliases read from the aliases file
pub fn read_old_aliases () -> ra::Result<Vec<String>> {
	use ra::Error::*;
	
	let path = terror! { file::find_aliases_file() => |_| FindFileF };
	let alias_file = terror! { File::open(&path) => |e| ra::IoF(path, e) };
	let alias_buf = io::BufReader::new(alias_file);
	
	let (line, path) = terror! { find_prefix_line(alias_buf, path) };
	
	let json_s = &line[JSON_PREFIX.len() .. ]; // May be empty
	let json = terror! { serde_json::from_str(json_s) => |e| FromJsonF(path, e) };
	Ok(json)
}

// ---

/// Write the alias file contents
fn write_aliases_text (file :&mut wa::Buf, config :&FullConfig, path :PathBuf)
					   -> wa::Result<PathBuf>
{
	#![allow(clippy::string_lit_as_bytes)]
	use wa::Error::*;
	use crate::util::shell_escape;

	/// Our writer function
	macro_rules! w {
		($e:expr) => {
			terror! { file.write_all($e.as_bytes()) => |e| WriteFileF(path, e) };
		}
	}

	let alias_json = terror! { serde_json::to_string(&config.alias) => |e| ToJsonF(path, e) };

	// Start writing
	w!("# Generated by switchable, modifications will be overwritten\n");

	// Used for keeping track of previous aliases to tell the user
	// what commands to unalias
	w!(format!("{}{}\n", JSON_PREFIX, alias_json));
	w!("\n");

	for cmd in &config.alias {
		let cmd = shell_escape(cmd);
		w!(format!("alias {cmd}='DRI_PRIME=1 '{cmd}\n", cmd=cmd));
	}

	w!("# End of file");
	Ok(path)
}

/// Module for `write_aliases`
pub mod wa {
	prelude!();
	use std::{io, result, fs::File, path::PathBuf};
	use super::NOHOME_FMSG;

	#[derive(ThisError, Debug)]
	pub enum Error {
		#[error("{}", NOHOME_FMSG)]
		FindFileF,
		#[error("Failed to write to aliases file {0:?}")]
		WriteFileF(PathBuf, #[source] io::Error),
		#[error("Failed to write the list of aliases as JSON in {0:?}")]
		ToJsonF(PathBuf, #[source] serde_json::Error),
		#[error("Aliases path {0:?} is not valid utf8")]
		PathNotUtf8(PathBuf),
	}

	pub type Result<T> = result::Result<T, self::Error>;
	pub type Buf = io::BufWriter<File>;
}

/// Writes the aliases file if it can. Aborts as soon as it encounters an error
pub fn write_aliases (config :&FullConfig) -> wa::Result<String> {
	use wa::Error::*;
	
	// Find and open file
	let path = terror! { file::find_aliases_file() => |_| FindFileF };
	let file = terror! {
		fs::OpenOptions::new()
		.write(true).create(true)
		.open(&path) => |e| WriteFileF(path, e)
	};
	let mut file = BufWriter::new(file);
	
	// Write text
	let path = terror! { write_aliases_text(&mut file, &config, path) };
	terror! { file.flush() => |e| WriteFileF(path, e) };

	// Return path as valid String
	let path = terror! {
		path.into_os_string().into_string() => |e| PathNotUtf8(PathBuf::from(e))
	};
	Ok(path)
}
